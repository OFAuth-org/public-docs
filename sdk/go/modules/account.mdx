---
title: "Account & Webhooks"
description: "Manage your OFAuth account, connections, settings, and handle webhook events"
---

## Account Info

Retrieve organization details for the authenticated API key.

```go
client := ofauth.NewClient("your-api-key")

account, err := client.Whoami(ctx)
if err != nil {
    log.Fatal(err)
}
fmt.Printf("Account: %s\n", account.Id)
```

## Connection Management

### List Connections

List all connections for your organization, optionally filtering by status.

```go
// List all connections
connections, err := client.ListAccountConnections(ctx, nil)
if err != nil {
    log.Fatal(err)
}
for _, conn := range connections.List {
    fmt.Printf("%s: %s (%s)\n", conn.Id, conn.UserData.Username, conn.Status)
}

// List with filters
connections, err = client.ListAccountConnections(ctx, &ofauth.RequestOptions{
    Query: url.Values{
        "status": []string{"active"},
        "limit":  []string{"10"},
    },
})
```

### Delete Connection

Disconnect a connection and log out the user. This stops billing for the connection.

```go
_, err := client.DeleteAccountConnections(ctx, "conn_xxx")
```

### Invalidate Connection

Mark a connection as expired and log out the user. The connection record is preserved, allowing the user to reconnect.

```go
_, err := client.AccountConnectionsInvalidate(ctx, "conn_xxx")
```

## Connection Settings

Get and update settings for individual connections, including vault cache configuration.

```go
// Get connection settings
settings, err := client.GetAccountConnectionsSettings(ctx, "conn_xxx")

// Update connection settings (use Request for simpler call)
_, err = client.Request(ctx, "PATCH", "/v2/account/connections/conn_xxx/settings", &ofauth.RequestOptions{
    Body: map[string]interface{}{
        "vaultPlus": map[string]interface{}{"enabled": true},
    },
})
```

## Organization Settings

Get and update organization-level settings, including default vault cache configuration.

```go
// Get org settings
orgSettings, err := client.GetAccountSettings(ctx)

// Update org settings (use Request for simpler call)
_, err = client.Request(ctx, "PATCH", "/v2/account/settings", &ofauth.RequestOptions{
    Body: map[string]interface{}{
        "vaultPlus":                  map[string]interface{}{"enabled": true},
        "applyToExistingConnections": true,
    },
})
```

---

## Webhook Verification

OFAuth sends webhook events using the [Svix](https://www.svix.com/) protocol with HMAC-SHA256 signatures. The Go SDK includes built-in verification and routing.

<Info>
  Webhooks are configured in the [OFAuth Dashboard](https://app.ofauth.com/platform/developers/webhooks). From there you can set your endpoint URL, select event types, view delivery history, and rotate secrets.
</Info>

### Event Types

<CardGroup cols={2}>
  <Card title="Connection Events" icon="link">
    **connection.created** — New connection established

    **connection.updated** — Connection status or data changed

    **connection.expired** — Connection session expired
  </Card>
  <Card title="System Events" icon="gear">
    **rules.updated** — Dynamic rules configuration changed
  </Card>
</CardGroup>

### Event Payload Structure

All webhook events follow the Svix format with these fields:

```json
{
  "eventType": "connection.created",
  "live": true,
  "data": {
    "connection": {
      "id": "conn_xxx",
      "platformUserId": "12345",
      "status": "active",
      "userData": {
        "userId": "12345",
        "name": "Display Name",
        "username": "creator",
        "avatar": "https://..."
      },
      "permissions": ["earnings:read", "subscribers:read"]
    },
    "clientReferenceId": "your-ref-id"
  }
}
```

### Verifying Signatures

<Warning>
  Always verify webhook signatures before processing events. The signing secret starts with `whsec_` and is available in your dashboard.
</Warning>

```go
import onlyfans_sdk "github.com/ofauth-org/onlyfans-sdk-go"

func webhookHandler(w http.ResponseWriter, r *http.Request) {
    headers, err := ofauth.ExtractWebhookHeaders(r)
    if err != nil {
        http.Error(w, "Missing headers", http.StatusUnauthorized)
        return
    }

    body, _ := io.ReadAll(r.Body)
    event, err := ofauth.VerifyWebhookPayload(body, headers, "whsec_your_signing_secret", 0)
    if err != nil {
        http.Error(w, "Invalid signature", http.StatusUnauthorized)
        return
    }

    fmt.Printf("Event: %s\n", event.EventType)
    w.WriteHeader(http.StatusOK)
}
```

### Webhook Router

The Go SDK provides a router that verifies signatures and dispatches events to typed handlers.

```go
import onlyfans_sdk "github.com/ofauth-org/onlyfans-sdk-go"

router := ofauth.NewWebhookRouter("whsec_your_signing_secret")

router.On("connection.created", func(event *ofauth.WebhookEvent) error {
    var data ofauth.ConnectionCreatedEventData
    if err := ofauth.ParseEventData(event, &data); err != nil {
        return err
    }
    fmt.Printf("New connection: %s (%s)\n", data.Connection.ID, data.Connection.UserData.Username)
    return nil
})

router.On("connection.expired", func(event *ofauth.WebhookEvent) error {
    var data ofauth.ConnectionExpiredEventData
    ofauth.ParseEventData(event, &data)
    fmt.Printf("Connection expired: %s\n", data.Connection.ID)
    return nil
})

// Use as http.Handler
http.Handle("/webhooks", router)
```

## Best Practices

<CardGroup cols={2}>
  <Card title="Webhook Security" icon="shield-check">
    - Always verify HMAC signatures before processing
    - Use HTTPS endpoints only
    - Rotate secrets periodically via the dashboard
    - Log events for debugging delivery issues
  </Card>
  <Card title="Reliability" icon="rotate">
    - Process events idempotently (you may receive duplicates)
    - Respond with `200` quickly, then process async
    - Monitor delivery history in the dashboard
    - Use the router's `onError` handler for graceful failures
  </Card>
</CardGroup>

<Note>
  For webhook delivery behavior and retry policies, see the [Webhooks reference](/reference/webhooks).
</Note>
