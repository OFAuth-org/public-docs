---
title: "Connection Management"
description: "List, monitor, import, and manage OnlyFans connections"
---

## Overview

Connections represent authenticated OnlyFans accounts linked to your organization. After a user completes the [Link flow](/sdk/modules/authentication/link-authentication), you receive a connection ID (`conn_xxx`) that you use for all Access API calls. This page covers managing those connections.

## List Connections

Retrieve all connections with optional filters for status, import type, and pagination.

<CodeGroup>
```typescript TypeScript
import { createOFAuthClient } from '@ofauth/onlyfans-sdk';

const client = createOFAuthClient({ apiKey: 'your-api-key' });

// List all connections
const connections = await client.account.connections.list({});
for (const conn of connections.list) {
  console.log(`${conn.id}: ${conn.userData.username} (${conn.status})`);
}

// Filter by status
const active = await client.account.connections.list({
  status: 'active',
  limit: 10,
});

// Filter by imported flag
const imported = await client.account.connections.list({
  imported: 'true',
});
```

```python Python
from onlyfans_sdk import OFAuthClient, account

client = OFAuthClient(api_key="your-api-key")

# List all connections
connections = account.list_connections(client)
for conn in connections["list"]:
    print(f"{conn['id']}: {conn['userData']['username']} ({conn['status']})")

# Filter by status
active = account.list_connections(client, status="active", limit=10)

# Filter by imported flag
imported = account.list_connections(client, imported="true")
```

```go Go
ctx := context.Background()
client := ofauth.NewClient("your-api-key")

// List all connections
connections, err := client.ListAccountConnections(ctx, nil)
if err != nil {
    log.Fatal(err)
}
for _, conn := range connections.List {
    fmt.Printf("%s: %s (%s)\n", conn.Id, conn.UserData.Username, conn.Status)
}

// Filter by status
active, err := client.ListAccountConnections(ctx, &ofauth.RequestOptions{
    Query: url.Values{
        "status": []string{"active"},
        "limit":  []string{"10"},
    },
})
```

```csharp C#
using OFAuth;

var client = new OFAuthClient("your-api-key");

// List all connections
var connections = await client.GetAsync<ConnectionsListResponse>(
    "/v2/account/connections"
);
foreach (var conn in connections.List)
{
    Console.WriteLine($"{conn.Id}: {conn.UserData.Username} ({conn.Status})");
}

// Filter by status
var active = await client.GetAsync<ConnectionsListResponse>(
    "/v2/account/connections",
    query: new Dictionary<string, string?>
    {
        ["status"] = "active",
        ["limit"] = "10"
    }
);
```
</CodeGroup>

### Query Parameters

| Parameter | Type | Description |
| --- | --- | --- |
| `status` | `"active"` \| `"expired"` \| `"awaiting_2fa"` | Filter by connection status |
| `imported` | `"true"` \| `"false"` | Filter by whether connection was imported |
| `limit` | `number` | Items per page (default 20) |
| `offset` | `number` | Number of items to skip |

## Pagination

### Automatic Iteration (TypeScript)

The TypeScript SDK provides an async iterator that handles pagination automatically:

```typescript
// Iterate over ALL connections, across all pages
for await (const connection of client.account.connections.iterate()) {
  console.log(connection.id, connection.userData.username);
}

// With options
for await (const connection of client.account.connections.iterate({
  status: 'active',
  maxItems: 100,
  pageSize: 20,
})) {
  console.log(connection.id);
}
```

### Generator Iteration (Python)

Python uses generators for automatic pagination:

```python
# Iterate over ALL connections, across all pages
for connection in account.iter_connections(client):
    print(connection["id"], connection["userData"]["username"])

# With options
for connection in account.iter_connections(
    client,
    status="active",
    max_items=100,
    page_size=20,
):
    print(connection["id"])
```

### Manual Pagination (Go, C#)

<CodeGroup>
```go Go
offset := 0
limit := 20

for {
    connections, err := client.ListAccountConnections(ctx, &ofauth.RequestOptions{
        Query: url.Values{
            "limit":  []string{fmt.Sprintf("%d", limit)},
            "offset": []string{fmt.Sprintf("%d", offset)},
        },
    })
    if err != nil {
        log.Fatal(err)
    }

    for _, conn := range connections.List {
        fmt.Printf("%s: %s\n", conn.Id, conn.UserData.Username)
    }

    if !connections.HasMore {
        break
    }
    offset += len(connections.List)
}
```

```csharp C#
var offset = 0;
var limit = 20;

while (true)
{
    var page = await client.GetAsync<ConnectionsListResponse>(
        "/v2/account/connections",
        query: new Dictionary<string, string?>
        {
            ["limit"] = limit.ToString(),
            ["offset"] = offset.ToString()
        }
    );

    foreach (var conn in page.List)
    {
        Console.WriteLine($"{conn.Id}: {conn.UserData.Username}");
    }

    if (!page.HasMore) break;
    offset += page.List.Count;
}
```
</CodeGroup>

## Connection Settings

Each connection has settings you can read and update, including vault cache configuration.

### Get Settings

<CodeGroup>
```typescript TypeScript
const settings = await client.account.connections.getSettings({
  connectionId: 'conn_xxx',
});

console.log('Connection:', settings.connectionId);
console.log('Vault cache enabled:', settings.vaultCache.enabled);
console.log('Storage used:', settings.vaultCache.stats.totalStorageBytes);
```

```python Python
settings = account.get_connection_settings(client, connection_id="conn_xxx")

print("Connection:", settings["connectionId"])
print("Vault cache enabled:", settings["vaultCache"]["enabled"])
```

```go Go
settings, err := client.GetAccountConnectionsSettings(ctx, "conn_xxx")
if err != nil {
    log.Fatal(err)
}

fmt.Println("Vault cache enabled:", settings.VaultCache.Enabled)
```

```csharp C#
var settings = await client.GetAsync<ConnectionSettingsResponse>(
    "/v2/account/connections/conn_xxx/settings"
);

Console.WriteLine($"Vault cache enabled: {settings.VaultCache.Enabled}");
```
</CodeGroup>

### Update Settings

<CodeGroup>
```typescript TypeScript
const updated = await client.account.connections.updateSettings({
  connectionId: 'conn_xxx',
  body: {
    vaultCache: {
      enabled: true,
      settings: {
        autoCacheVault: true,
        cacheImages: true,
        cacheVideos: true,
      },
    },
  },
});
```

```python Python
updated = account.update_connection_settings(
    client,
    connection_id="conn_xxx",
    body={
        "vaultCache": {
            "enabled": True,
            "settings": {
                "autoCacheVault": True,
                "cacheImages": True,
                "cacheVideos": True,
            },
        },
    },
)
```

```go Go
updated, err := client.UpdateAccountConnectionsSettings(ctx, "conn_xxx", struct {
    VaultCache *struct {
        Enabled  *bool       `json:"enabled,omitempty"`
        Settings interface{} `json:"settings,omitempty"`
    } `json:"vaultCache,omitempty"`
}{
    VaultCache: &struct {
        Enabled  *bool       `json:"enabled,omitempty"`
        Settings interface{} `json:"settings,omitempty"`
    }{
        Enabled: boolPtr(true),
        Settings: map[string]interface{}{
            "autoCacheVault": true,
            "cacheImages":    true,
            "cacheVideos":    true,
        },
    },
})
```

```csharp C#
var updated = await client.PatchAsync<ConnectionSettingsUpdateResponse>(
    "/v2/account/connections/conn_xxx/settings",
    body: new
    {
        vaultCache = new
        {
            enabled = true,
            settings = new
            {
                autoCacheVault = true,
                cacheImages = true,
                cacheVideos = true
            }
        }
    }
);
```
</CodeGroup>

## Delete Connection

Permanently disconnect an account. This logs the user out and stops billing for the connection.

<CodeGroup>
```typescript TypeScript
try {
  await client.account.connections.delete({
    connectionId: 'conn_xxx',
  });
  console.log('Connection deleted');
} catch (error) {
  console.error('Failed to delete:', error);
}
```

```python Python
try:
    account.delete_connections(client, connection_id="conn_xxx")
    print("Connection deleted")
except Exception as e:
    print("Failed to delete:", e)
```

```go Go
_, err := client.DeleteAccountConnections(ctx, "conn_xxx")
if err != nil {
    log.Fatal(err)
}
fmt.Println("Connection deleted")
```

```csharp C#
await client.DeleteAsync<object>("/v2/account/connections/conn_xxx");
Console.WriteLine("Connection deleted");
```
</CodeGroup>

<Warning>
  Deleting a connection is permanent. The user must re-authenticate through Link to restore access.
</Warning>

## Invalidate Connection

Mark a connection as expired without deleting it. The connection record is preserved, allowing the user to reconnect with updated permissions.

<CodeGroup>
```typescript TypeScript
await client.account.connections.invalidate({
  connectionId: 'conn_xxx',
});
console.log('Connection invalidated — user must re-authenticate');
```

```python Python
account.invalidate_connections(client, connection_id="conn_xxx")
print("Connection invalidated — user must re-authenticate")
```

```go Go
_, err := client.AccountConnectionsInvalidate(ctx, "conn_xxx")
if err != nil {
    log.Fatal(err)
}
fmt.Println("Connection invalidated — user must re-authenticate")
```

```csharp C#
await client.PostAsync<object>(
    "/v2/account/connections/conn_xxx/invalidate"
);
Console.WriteLine("Connection invalidated — user must re-authenticate");
```
</CodeGroup>

### Invalidate vs Delete

| | Invalidate | Delete |
| --- | --- | --- |
| Connection record | Preserved | Removed |
| User can reconnect | Yes, with same connection ID | Must create new connection |
| Use case | Force re-auth, update permissions | Full disconnect, stop billing |

## Import Connection

Import an externally managed OnlyFans session. Imported connections are not billed monthly and are not health-checked. They can be used through the Access API immediately.

<CodeGroup>
```typescript TypeScript
const imported = await client.account.connections.createImport({
  body: {
    cookie: 'sess=your_session; auth_id=12345; auth_uid_12345=xxx',
    userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
    permissions: ['profile:read', 'posts:read', 'messages:read'],
    clientReferenceId: 'my-ref-123',
  },
});

console.log('Imported connection:', imported.id);
console.log('Status:', imported.status);
console.log('User:', imported.userData.username);
```

```python Python
imported = account.create_connections_connections_import(
    client,
    body={
        "cookie": "sess=your_session; auth_id=12345; auth_uid_12345=xxx",
        "userAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
        "permissions": ["profile:read", "posts:read", "messages:read"],
        "clientReferenceId": "my-ref-123",
    },
)

print("Imported connection:", imported["id"])
print("Status:", imported["status"])
print("User:", imported["userData"]["username"])
```

```go Go
cookie := "sess=your_session; auth_id=12345; auth_uid_12345=xxx"
userAgent := "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
imported, err := client.CreateAccountConnectionsImport(ctx, struct {
    Cookie            string   `json:"cookie"`
    UserAgent         string   `json:"userAgent"`
    Permissions       []string `json:"permissions,omitempty"`
    ClientReferenceId *string  `json:"clientReferenceId,omitempty"`
}{
    Cookie:      cookie,
    UserAgent:   userAgent,
    Permissions: []string{"profile:read", "posts:read", "messages:read"},
})
if err != nil {
    log.Fatal(err)
}

fmt.Println("Imported connection:", imported.Id)
fmt.Println("Status:", imported.Status)
fmt.Println("User:", imported.UserData.Username)
```

```csharp C#
var imported = await client.PostAsync<ConnectionImportResponse>(
    "/v2/account/connections/import",
    body: new
    {
        cookie = "sess=your_session; auth_id=12345; auth_uid_12345=xxx",
        userAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
        permissions = new[] { "profile:read", "posts:read", "messages:read" },
        clientReferenceId = "my-ref-123"
    }
);

Console.WriteLine($"Imported connection: {imported.Id}");
Console.WriteLine($"Status: {imported.Status}");
Console.WriteLine($"User: {imported.UserData.Username}");
```
</CodeGroup>

### Update Imported Session

Refresh an imported connection's session data without deleting and re-importing:

<CodeGroup>
```typescript TypeScript
const updated = await client.account.connections.updateImport({
  connectionId: 'conn_xxx',
  body: {
    cookie: 'sess=new_session; auth_id=12345; auth_uid_12345=yyy',
    userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
  },
});

console.log('Session updated:', updated.id, updated.status);
```

```python Python
updated = account.update_connections_connections_import(
    client,
    connection_id="conn_xxx",
    body={
        "cookie": "sess=new_session; auth_id=12345; auth_uid_12345=yyy",
        "userAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
    },
)

print("Session updated:", updated["id"], updated["status"])
```

```go Go
updated, err := client.UpdateAccountConnectionsImport(ctx, "conn_xxx", struct {
    Cookie    string `json:"cookie"`
    UserAgent string `json:"userAgent"`
}{
    Cookie:    "sess=new_session; auth_id=12345; auth_uid_12345=yyy",
    UserAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
})
```

```csharp C#
var updated = await client.PatchAsync<ConnectionImportResponse>(
    "/v2/account/connections/import/conn_xxx",
    body: new
    {
        cookie = "sess=new_session; auth_id=12345; auth_uid_12345=yyy",
        userAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
    }
);
```
</CodeGroup>

<Info>
  The new session must belong to the **same OnlyFans user** (matched by user ID from the cookie). This preserves the connection ID across session refreshes.
</Info>

## Connection Statuses

| Status | Description |
| --- | --- |
| `active` | Connection is valid and can be used for API calls |
| `expired` | Session has expired — user needs to re-authenticate via Link |
| `awaiting_2fa` | Waiting for 2FA verification to complete |

## Next Steps

<CardGroup cols={2}>
  <Card title="Access API" icon="database" href="/sdk/modules/posts">
    Use connection IDs to fetch OnlyFans data
  </Card>
  <Card title="Webhooks" icon="webhook" href="/reference/webhooks">
    Get notified when connections expire or change status
  </Card>
</CardGroup>
